# Example MVC NodeJS

- MVC example with NodeJS + TypeScript + Express + MySQL 5.7

----------
**필요사항**
- MySQL 5.7 환경이 필요합니다.
- 

**구성 방법**

종속성 설치

    npm install

에플리케이션 실행

    npm start

**설계방향성**

### 테스트 환경 구성
jest를 사용하여 테스트 주도적인 개발 경험이 없다보니,
기초적인 선언여부, 호출 여부, 인자 전달과
postman을 통한 실행 검증 검사만을 하였지만
인프랩에서 구매한 TDD강의에서 supertest 등 
다양한 테스트 자동화도 구성하고 싶습니다.

### 개발 환경 선택
기존에 리눅스 rocky linux 환경에서 배포를 계획하고 있었으나, 원격 환경으로 구성하였지만,
원격 환경보다 로컬 환경에서 간단하게 구현하는 것이 정해진 기간을 맞추기 위한 적합한 방법이라 생각하여
리눅스 환경과 유사한 Mac Os 환경에서 개발을 진행하였습니다.

### Mysql 혹은 Pg
단순 웹 서비스를 구현하기에는 구성 및 설정이 용의한 Mysql을 채택하는 것이 좋을 것이라 판단하하였습니다.

### TypeDI
node.js 데이코레이션을 통한 서비스 등록등 적은 단시간에 학습하여 적용하지 좋은 것이라고 판단하여 채택하였습니다.

### class-validator
node.js validator를 사용한 경험은 없었으나 spring 하이버네이트 validator와 유사한 형태인 것 같아 사용에는 어려움이 없었던 것 같습니다.
하지만 기존에 사용해보지 못하였던 라이브러리라는 점에서 처음부터 코드를 작성할 때 사용하지는 않았으며 후반 코드 고도화 작업에서 사용하기 위하여
채택하였습니다.

### mysql2/promise 선택 이유
mysql2/promise를 선택한 큰 이유는 프로미스 패턴을 통한 기존 콜백 패턴과 대비된 장점때문에 채택하게 되었습니다.
1. 코드 가독성 
2. 에러처리 일관성
3. 코드 단순화

위와 같은 장점으로 mysql2/promise 채택하였습니다.


**구현 과정 중 마주한 상황**

## repository 저장소 클래스 형태

1. DAO를 사용하는 방식
장점
   * 응집도 증가 : 각 서비스 클래스가 필요한 DAO를 직접 주입받아 사용하므로 서비스 클래스의 역할이 명확해진다.
   * 유연성: 각 서비스 클래스에서 필요한 DAO의 메서드를 자유롭게 사용하고 확장할 수 있습니다. 서비스 로직 변경 시 영향 범위가 한정됩니다.
   * 테스트 용이성: 개별적으로 테스트하기가 쉽습니다. 각 서비스 클래스는 자신에게 필요한 DAO만 모킹(mocking)하면 됩니다.
단점
   * 코드 중복 : 여러 서비스 클래스에서 비슷한 DAO 호출 로직이 반복될 수 있습니다.
   * 유지 보수 어려움 : 여러 서비스 클래스에서 동일한 기능을 변경해야 할 경우, 수정 범위가 넓어질 수 있습니다.

2. 하나의 공용 함수 사용
장점
   * 코드 재사용성 : 공통 로직을 하나의 함수로 작성하여 여러 서비스 클래스에서 재사용할 수 있습니다.
   * 유지 보수 용이 : 공통 기능을 수정할 때 한 곳만 수정하면 됩니다.
단점
   * 응집도 감소: 공용 함수를 사용하는 서비스 클래스들이 서로 의존성이 생길 수 있습니다.
   * 유연성 감소: 공용 함수가 여러 서비스 클래스의 요구사항을 모두 만족시키기 어려울 수 있습니다. 공용 함수가 복잡해질 수 있습니다.
   * 테스트 어려움: 공용 함수 자체를 모킹하거나 테스트하기 어렵고, 이를 사용하는 서비스 클래스들끼리의 의존성 때문에 테스트가 복잡해질 수 있습니다.

결론
서비스 클래스별 개별 DAO 사용은 응집도를 높이고 유연성을 제공하며 테스트하기 쉽습니다. 하지만 코드 중복과 유지보수의 어려움이 있을 수 있습니다.
하나의 공용 함수 사용은 코드 재사용과 유지보수 용이성을 제공하지만, 응집도와 유연성 면에서 단점이 있으며 테스트하기 어렵습니다.


## jest를 사용한 TDD 개발
jest를 통한 TDD 테스트 주도적 개발 환경을 경험한 적이 없어 강의를 급하게 찾아보며 감각을 익혀보았지만,
환경 세팅 부터 검사 대상 클래스의 의존성을 mock하여 주입해주는 것이 많이 어려웠습니다. 대표적인 문제 상황들은 아래와 같았습니다.

1. 비동기 코드 테스트
test('fetches data successfully', async () => {
  const data = await fetchData();
  expect(data).toEqual(expectedData);
});

2. Mocking
jest.mock('./dependencyModule');
import { dependencyFunction } from './dependencyModule';

3. 테스크 격리
beforeEach(() => {
  // Initialize or reset state
});
afterEach(() => {
  // Clean up
});

4. 테스트 시 의존성 주입
import { Container } from 'typedi';

class MockService {}

beforeEach(() => {
  Container.set(RealService, new MockService());
});
잘못된 생성으로 인스턴스 제대로 초기화 되지 않는 문제가 발생

5. 서비스 인스턴스 관리
beforeEach(() => {
  Container.reset();
});

테스트 환경에서 TypeDI의 서비스 인스턴스가 제대로 초기화되지 않으면 테스트가 실패할 수 있습니다. beforeEach 또는 beforeAll 훅을 사용해 매번 새로 초기화해야 할 수 있습니다.

## 상태코드 및 메서드


## 데이터 베이스 맵핑 구성

문자열 값을 정수로 변환하여 저장하고 뷰 테이블을 사용하는 방식은 공간 절약과 중복 최소화하는 맵핑 방식을 적용하였습니다.
맵핑 방식의 장단점은 아래와 같다고 할 수 있습니다.

### 장점
* 공간 절약
* 중복 최소화
* 빠른 검색 및 인덱싱
* 데이터 참조 일관성:

### 단점
* 복잡성 증가
* 성능 오버헤드
* 데이터 일관성 문제
* 추가 관리 작업
* 직관성 감소

성능 오버헤드 문제가 발생할 수 있는 가능성이 있으나, view 테이블 저장공간에 보관되기 때문에 성능상 문제가 되지 않을 것이라고 생각하였습니다.
직관성 감소 또한 데이터 조회 시 별도 맵핑 테이터를 저장하는 테이블과 대상 테이블을 view로 합쳐 관리한다면, 데이터를 임으로 수정할 수 없기때문에 보안점인 이점도 얻을 수 있습니다. 

이러한 극복 가능한 단점에 비하여 얻는 이점인 빠른 검색 및 다양한 서브쿼리 높은 활용성을 위하여 채택하였습니다.


단점에 비하여 얻는 이점인 빠른 검색 및 다양한 서브쿼리 높은 활용성을 위하여 채택하였습니다.

## req.body 클래스 변환
req.body와 req.query 에서 반환받은 json 값이 클래스 인스턴스가 아니라는 것으로 처음에는 알지 못하였습니다.
class-validator 사용하여도 검사가 돠지 않아 알아보니 단순한 리터럴 객체로 인스턴스로 변환하기 위해서는 
class-transformer 사용하여 변환하고자하는 타입의 클래스 인스턴스로 맵핑하여 해결하였습니다.
